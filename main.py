from processes import Process
from readyqueue import ReadyQueue
import tracemalloc
import sys
import math
import time

import fcfs
import sjf
import srt

Xi = 0

def reset(processes, l):
    for p in processes:
        p.reset()
        p.tau = math.ceil(1/l)
    return l

def srand48(seedval: int) -> None:
    """
    Initializes the sequence of 48-bit Xi integers generated by drand48().

    Sets the high order 32-bits of Xi to the argument seedval. The low order
    16-bits are set to the arbitrary value 0x330E.

    https://linux.die.net/man/3/srand48
    """
    global Xi
    Xi = ((seedval & 0xFFFFFFFF) << 16) + 0x330E

def drand48() -> float:
    """
    Returns non-negative double-precision floating-point values uniformly
    distributed between [0.0, 1.0) according to the linear congruential
    formula.

    Xn+1 = (aXn + c) mod m, where:
    - m = 2^48
    - a = 0x5DEECE66D
    - c = 0xB

    Should only be called after srand48() is used to initialize the seed.

    https://linux.die.net/man/3/drand48
    """
    global Xi
    Xi = (0x5DEECE66D * Xi + 0xB) % (2**48)
    return Xi / (2**48)

def next_exp(upper_bound,lambda_val):

    r = drand48()

    x = -math.log( r ) / lambda_val
    while (x > upper_bound):
        r = drand48()
        x = -math.log( r ) / lambda_val

    return x

def create_processes(n, n_cpu, process_names, upper, l, alpha):
    processes = []
    for i in range(0, n):
        p_arrival = math.floor(next_exp(upper,l))
        num_bursts = math.ceil(drand48() * 32)
        bursts = []
        for j in range(0, num_bursts - 1):
            cpu_burst = math.ceil(next_exp(upper,l)) * (3 * (i < n_cpu) + 1)
            io_burst = math.ceil(next_exp(upper,l)) * (7 * (i >= n_cpu) + 1)
            bursts.append([cpu_burst,io_burst])
        cpu_burst = math.ceil(next_exp(upper,l)) * (3 * (i < n_cpu) + 1)
        bursts.append([cpu_burst])
        tau = math.ceil(1/l)
        processes.append(Process(pid=process_names[i], arrival_time=p_arrival, bursts=bursts,
                                process_type=(i<n_cpu), alpha=alpha, tau=tau))
    return processes

if __name__ == "__main__":

    tracemalloc.start()
    start_time = time.time()

    if len(sys.argv) != 9:
        print("ERROR: invalid arguments")
        exit()

    n = int(sys.argv[1])
    n_cpu = int(sys.argv[2])
    seed = int(sys.argv[3])
    l = float(sys.argv[4])
    upper = int(sys.argv[5])
    t_cs = int(sys.argv[6])
    alpha = float(sys.argv[7])
    t_slice = int(sys.argv[8])

    # if (n_cpu == 1):
    #     print(f"<<< -- process set (n={n}) with {n_cpu} CPU-bound process")
    # else:
    #     print(f"<<< -- process set (n={n}) with {n_cpu} CPU-bound processes")
    # print(f"<<< -- seed={seed}; lambda={l:.6f}; bound={upper}")
    # print()

    srand48( seed )

    alphabet = []
    for i in range(26):
        alphabet.append(chr(i+65))

    processes = []
    for a in alphabet:
        for i in range(10):
            processes.append(f"{a}{i}")


    ''' beware of aliasing '''
    p = create_processes(n, n_cpu,processes,upper,l,alpha)

    # for p in l:
    #     print(p)

    fcfs.fcfs(p,t_cs)
    reset(p, l)
    sjf.sjf(p,t_cs)
    reset(p, l)
    srt.srt(p,t_cs)

    #q = ReadyQueue(l, t_cs)
    # print("<<< PROJECT SIMULATIONS")
    # print(f"<<< -- t_cs={t_cs}ms; alpha={alpha}; t_slice={t_slice}ms")
    #q.sjf()
    #q.fcfs()
    print("<<< -- MEMORY USAGE")
    current, peak = tracemalloc.get_traced_memory()
    print(f"<<< -- -- current: {current / 10**6:.6f}MB; peak: {peak / 10**6:.6f}MB")
    tracemalloc.stop()
    print("<<< -- CPU TIME")
    print(f"<<< -- -- {time.time() - start_time:.6f} seconds")
    print("<<< -- END OF SIMULATION")
