from process import Process
from readyqueue import ReadyQueue
from event import Event
import sys
import math

Xi = 0

def srand48(seedval: int) -> None:
    """
    Initializes the sequence of 48-bit Xi integers generated by drand48().

    Sets the high order 32-bits of Xi to the argument seedval. The low order
    16-bits are set to the arbitrary value 0x330E.

    https://linux.die.net/man/3/srand48
    """
    global Xi
    Xi = ((seedval & 0xFFFFFFFF) << 16) + 0x330E

def drand48() -> float:
    """
    Returns non-negative double-precision floating-point values uniformly
    distributed between [0.0, 1.0) according to the linear congruential
    formula.

    Xn+1 = (aXn + c) mod m, where:
    - m = 2^48
    - a = 0x5DEECE66D
    - c = 0xB

    Should only be called after srand48() is used to initialize the seed.

    https://linux.die.net/man/3/drand48
    """
    global Xi
    Xi = (0x5DEECE66D * Xi + 0xB) % (2**48)
    return Xi / (2**48)

def next_exp(upper_bound,lambda_val):
    
    r = drand48()

    x = -math.log( r ) / lambda_val
    while (x > upper_bound):
        r = drand48()
        x = -math.log( r ) / lambda_val
    
    return x

def create_cpu_process(n, process_names, upper, l, alpha):
    processes = []
    for i in range(0, n):
        p_arrival = math.floor(next_exp(upper,l))
        num_bursts = math.ceil(drand48() * 32)
        bursts = []
        for j in range(0, num_bursts-1):
            cpu_burst = math.ceil(next_exp(upper,l)) * 4 
            io_burst = math.ceil(next_exp(upper,l))
            bursts.append([cpu_burst,io_burst])
        cpu_burst = math.ceil(next_exp(upper,l)) * 4 
        bursts.append([cpu_burst])
        tau = math.ceil(1/l)
        processes.append(Process(pid=process_names[i], arrival_time=p_arrival, bursts=bursts,
                                  process_type="CPU-bound", alpha=alpha, tau=tau))
    return processes

def create_io_process(n, process_names, upper, l, alpha):
    processes = []
    for i in range(0, n):
        p_arrival = math.floor(next_exp(upper,l))
        num_bursts = math.ceil(drand48() * 32)
        bursts = []
        for j in range(0, num_bursts-1):
            cpu_burst = math.ceil(next_exp(upper,l)) 
            io_burst = math.ceil(next_exp(upper,l)) * 8
            bursts.append([cpu_burst,io_burst])
        cpu_burst = math.ceil(next_exp(upper,l)) 
        bursts.append([cpu_burst])
        tau = math.ceil(1/l)
        processes.append(Process(pid=process_names[i], arrival_time=p_arrival, bursts=bursts, 
                                 process_type="I/O-bound", alpha=alpha, tau=tau))
    return processes

if __name__ == "__main__":

    if len(sys.argv) != 9:
        print("ERROR: invalid arguments")
        exit()

    n = int(sys.argv[1])
    n_cpu = int(sys.argv[2])
    seed = int(sys.argv[3])
    l = float(sys.argv[4])
    upper = int(sys.argv[5])
    t_cs = int(sys.argv[6])
    alpha = float(sys.argv[7])
    t_slice = int(sys.argv[8])
    
    # if (n_cpu == 1):
    #     print(f"<<< -- process set (n={n}) with {n_cpu} CPU-bound process")
    # else:
    #     print(f"<<< -- process set (n={n}) with {n_cpu} CPU-bound processes")
    # print(f"<<< -- seed={seed}; lambda={l:.6f}; bound={upper}")
    # print()

    srand48( seed )

    alphabet = []
    for i in range(26):
        alphabet.append(chr(i+65))
    
    processes = []
    for a in alphabet: 
        for i in range(10):
            processes.append(f"{a}{i}")

    
    ''' beware of aliasing '''
    l = create_cpu_process(n_cpu,processes[0:n_cpu],upper,l,alpha) + create_io_process(n-n_cpu,processes[n_cpu:],upper,l,alpha)

    # for p in l:
    #     print(p)
    q = ReadyQueue(l, t_cs)
    # print("<<< PROJECT SIMULATIONS")
    # print(f"<<< -- t_cs={t_cs}ms; alpha={alpha}; t_slice={t_slice}ms")
    q.sjf()